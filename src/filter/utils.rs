use nalgebra as na;
use super::super::config::*;
use super::super::geometry::traits::{Plane, Transform};

#[macro_use]
use super::macros;


/// Placeholder function for some form of effective seeding for Mat5's
pub fn seed_covariance() -> Mat5 {
    // create a matrix with every element being .1
    let mut base = Mat5::zeros();
    base.fill(0.1);

    let id = Mat5::identity();

    return base + id;

}

/// Calculate the first filtered state vector estimate based on the 
/// global starting position of the particle and the the location
/// of the sensor it is supposed to hit

// NOTE: this function is basically a wrapper around `seed_state_vec_from_points` 
//          for ease of writing tests
pub fn seed_state_vec_from_sensor<T: Plane + Transform>(
    start_location: &P3, 
    first_sensor: &T
    ) -> Vec5 {

    let global_end = first_sensor.global_center();
    let local_end = first_sensor.to_local(*global_end);     // TODO store local_center so we dont need this conversion

    seed_state_vec_from_points(&start_location, &global_end, &local_end)

}


/// Calculate the first filtered state vector based on global point starting position,
/// local ending location, and global ending location
pub fn seed_state_vec_from_points(
    global_start_location: &P3,
    global_destination: &P3,
    local_destination: &P2
    ) -> Vec5{

    // position vector from begining point to ending point
    let vector_to_sensor = global_destination - global_start_location;

    // fetch local hit measurements
    get_unchecked!{vector; vector_to_sensor;
        eLOC_0 => x,
        eLOC_1 => y
    }

    let z_axis = Vec3::new(0., 0., 1.);
    let x_axis = Vec3::new(1., 0., 0.);

    // on the XY projection we construct, if we are in quadrants 3 or 4 then the angle
    // generated by .angle() will be x instead of 2pi - x (returns smallest angle between vectors). 
    // we do this here to reduce copies.
    let adjust_factor = 
        if y < &0. {true}
        else {false};

    let xy_projection = Vec3::new(*x, *y, 0.);

    let _phi = xy_projection.angle(&x_axis);

    // if we are in quadrants 3/4 we need to adjust for the angle in _phi
    let phi = 
        if adjust_factor{ (2. * PI) - _phi }
        else{ _phi };

    let theta = vector_to_sensor.angle(&z_axis);
    
    let mut seed_vec = Vec5::zeros();

    edit_matrix!{seed_vec;
        [eLOC_0] = local_destination.x,
        [eLOC_1] = local_destination.y,
        [ePHI]   = phi,
        [eTHETA] = theta,
        [eQOP] = 1.
    }

    seed_vec
}



/// Creates a vector of `num` length with Mat5 components
pub fn vec_of_mat(num: usize) -> Vec<Mat5> {
    
    let mut return_vec: Vec<Mat5> = Vec::with_capacity(num);
    (0..num).into_iter()
        .for_each(|_| return_vec.push(seed_covariance()));
    
    return return_vec
}

/// Creates a vector of `num` length with Vec5 components
pub fn vec_of_vec(num: usize) -> Vec<Vec5> {
    
    let mut return_vec: Vec<Vec5> = Vec::with_capacity(num);
    (0..num).into_iter()
        .for_each(|_| return_vec.push(Vec5::new_random()));
    
    return return_vec
}

#[derive(Debug)]
pub struct SmoothedData {
    pub state_vec: Vec<Vec5>,
    pub cov_mat: Vec<Mat5>,
    pub res_mat: Vec<Mat2>,
    pub res_vec: Vec<Vec2>
}

impl SmoothedData{
    pub fn new(state_vec: Vec<Vec5>,
            cov_mat: Vec<Mat5>,
            res_mat: Vec<Mat2>,
            res_vec: Vec<Vec2>) -> Self {

        return SmoothedData{state_vec: state_vec, 
                            cov_mat: cov_mat, 
                            res_mat: res_mat, 
                            res_vec:res_vec}
    }
    pub fn FFI_return() {
        unimplemented!()
    }
}

pub fn matrix_cross_product(matrix: &mut Mat4, vector: &Vec3) {
    for i in 0..4{
        submatrix!{matrix;
            (i,0), (3,1) => mut_column
        }
        
        // since mut_column is a dynamic matrix we cannot dereference and set equal
        let cross_result = mut_column.cross(&vector);

        edit_matrix!{mut_column;
            [0,0] = cross_result.x,
            [1,0] = cross_result.y,
            [2,0] = cross_result.z
        }

    }
}


pub fn simulate_cross_product(input_matrix:&mut Mat4, b_field: &Vec3, direction: &Vec3, qop: Real) {


    get_unchecked!{vector;b_field;
        0 => mag_x,
        1 => mag_y,
        2 => mag_z
    }

    get_unchecked!{vector;direction;
        0 => dir_x,
        1 => dir_y,
        2 => dir_z
    }

    edit_matrix!{input_matrix;
        [0,1] = qop*mag_z,
        [0,2] = -qop *mag_y,
        [0,3] = (dir_y * mag_z) - (dir_z * mag_y),

        [1,0] = -qop*mag_z,
        [1,2] = qop *mag_x,
        [1,3] = (dir_z * mag_x) - (dir_x * mag_z),
        
        [2,0] = qop *mag_y,
        [2,1] = -qop * mag_x,
        [2,3] = (dir_x * mag_y) - (dir_y * mag_x)

    }
    
}

